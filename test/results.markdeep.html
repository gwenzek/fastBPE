<meta charset="utf-8">

                            **Comparison of BPE implementation**

# Goal

I rewrote the fastBPE from C++ to Zig.
The main goal was to actually learn Zig on a small project performance oriented.
I'm also interested in the performance impact of changing language.
C++ claims to be as fast as C while Zig claims to be faster than C thanks to better defaults.

# Zig implementation

The first implementation was very much a translation of the C++ implementation, as I wanted to keep things comparable.
The main difference is memory allocation.
In Zig memory implementation is more explicit than in C++ and a bit more cumbersome.
I decided to make the Zig version prealloacate memory and to not allocate during processing.
The C++ implementation also do a lot of small string concatenations which was replaced by array slicing in Zig.

# Benchmark

I evaluated the "apply" part of the algorithm starting from learned codes.
The corpus used as input is 800k words long and is extracted from the French Wikipedia.
All implementation produce the exact same files.

For C++ there are two implementations:
* `apply` takes a whole file, load it memory and treat it with 4 threads.
* `apply_stream` read from stdin and process lines one by one in a single thread.

I'm more interested by the second version because they are different use case where I won't have the file on disk:
* The text is stored in compressed in a .gz file
* The text on the disk is not tokenized and is piped through a tokenizer before BPE.
* I don't want to preprocess 100Gb of text before starting working on the next step.

The Zig implementation has only the stream, single core implemented yet.
So unless mentioned implementation refers to the stream mode.
`C++ (batch)` refers to the implementation with in memory file and 4 threads.

| Implementation | Time  | Word / s |
|:---------------|------:|---------:|
| C++ (batch)    | 0.47s | 1702k/s  |
| C++            | 2.92s |  274k/s  |
| Zig            | 0.97s |  825k/s  |


# Python wrapper

Another thing I wanted to evaluate with this project is to compare the different way of writing C extension for Python.


There are 3 main alternatives: Cython, pybind11, cffi.
Here is a table comparing them summarizing from Stephan [Behnel] blog

|   Tool   | API language | Static  | Fast |
|:--------:|:-------------|:--------|:-----|
|  Cython  | Python-like  | static  | fast |
| pybind11 | C++          | static  | fast |
|   cffi   | Python       | dynamic | slow |
|   ctypes | Python       | dynamic | slow |


[#Behnel]: [Cython, pybind11, cffi – which tool should you choose?](http://blog.behnel.de/posts/cython-pybind11-cffi-which-tool-to-choose.html) - Stefan Behnel

## Python Wrapper Benchmark

I was curious about the performance impact of the chosen python wrapper and the general overhead.
The python code is pretty minimal and called Python functions are mostly direct C calls,
with some string encoding.
So I was expecting the Python impact to be negligible.

```py
import fastBPE, sys, time

def apply(file: str, codes: str) -> None:
    start = time.time()
    f = sys.stdin if file == "-" else open(file, mode="r")
    bpe = fastBPE.fastBPE(codes, "")
    for i, line in enumerate(f):
        s = bpe.apply([line[:-1]])[0]
        print(s)

    delay = time.time() - start
    print(f"Computed BPE on {i} sentences in {delay:.2f}s, using cython wrapper around cpp implementation", file=sys.stderr)
```


| Implementation |  Time | Word / s | Overhead |
|:---------------|------:|---------:|:---------|
| C++            | 2.92s |    274/s | 1× (ref) |
| C++ - Cython   | 2.79s |    287/s | 0.95×    |
|----------------|-------|----------|----------|
| Zig            | 1.06s |    755/s | 1× (ref) |
| Zig - Ctypes   | 1.07s |    748/s | 1.01×    |

I'm not sure why the Cython implementation is faster than C++,
The exact number varies across runs but I found the small speed up to be constistent.
Maybe it's due to the Python IO being faster than `stdio.h` ? I don't know ^^

## Flame graph

I used [py-spy](https://www.benfrederickson.com/profiling-native-python-extensions-with-py-spy/) to benchmark the two python wrappers.

![C++ - Cython](./cpp_cython.svg)
<!-- TODO: regenerate zig flame graph -->
<!-- ![Zig - Ctypes](./zig_ctypes.svg) -->


<!-- Markdeep footer -->
    <style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
    <script src="markdeep.min.js"></script>
    <script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script>
    <script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
